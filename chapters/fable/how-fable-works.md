# Understanding how Fable works

The compiler operates on F# source code directly, using the [F# Compiler Services](https://www.nuget.org/packages/FSharp.Compiler.Service) being part of [dotnet/fsharp](https://github.com/dotnet/fsharp) for parsing and type-checking the code. Once the code is parsed, a representation of the F# code's structure is obtained, also known as an abstract syntax tree (AST). This structure is then transformed into a specialized simpler Fable AST that is easier to work with. Then using a specialized printer, Fable translates the AST into JavaScript modules. By default, every F# file ends up being a single JavaScript file/module even if the F# source file has multiple modules defined.

The `F# AST -> Fable AST` transformation is implemented as a set of what is called *replacements*. Parts of the F# code are replaced with parts of JavaScript code that is implemented in an internal library called `fable-library`. Users of Fable don't typically interact with it but it is fun to poke around and see what Fable implements as an alternative for the corresponding .NET constructs. The code is very readable actually most of the time. That is until you start writing active patterns and use nested pattern matching. That is alright, though. Generating _idiomatice_ JavaScript is something that Fable tries its best at but it doesn't always work out. Mainly because writing a pretty piece of F# code can't always be expressed with the same conciseness in JavaScript.

The fact that we use a bundler to bundle the generated JavaScript into a single JS file is actually optional and has to do with the fact that we want to create a website. When building F# projects for Node.js environments, the output can be multiple JavaScript files referencing (i.e. `requiring`) each other while preserving the same input F# project structure that Fable compiled.